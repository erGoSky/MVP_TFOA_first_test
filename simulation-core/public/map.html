<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>World Map - TFOA</title>
    <link rel="stylesheet" href="map.css">
</head>
<body>
    <nav>
        <a href="/">üìä Dashboard</a>
        <a href="/map" class="active">üó∫Ô∏è Map</a>
    </nav>

    <div class="container">
        <div class="map-container">
            <!-- Control Panel -->
            <div class="control-panel">
                <div class="control-panel-title">‚öôÔ∏è Simulation Control</div>
                <div class="control-buttons">
                    <button id="playBtn" class="control-btn">‚ñ∂Ô∏è Play</button>
                    <button id="pauseBtn" class="control-btn pause-btn">‚è∏Ô∏è Pause</button>
                </div>
                <div class="speed-buttons">
                    <button class="speed-btn" data-speed="1">x1</button>
                    <button class="speed-btn" data-speed="2">x2</button>
                    <button class="speed-btn" data-speed="4">x4</button>
                    <button class="speed-btn" data-speed="8">x8</button>
                    <button class="speed-btn" data-speed="16">x16</button>
                </div>
            </div>

            <canvas id="worldCanvas" width="1600" height="1600"></canvas>
            <div id="hoverCard" class="hover-card"></div>
        </div>

        <div class="sidebar">
            <div class="info-panel">
                <div class="info-title">World Info</div>
                <div class="stat-row">
                    <span>Grid Size:</span>
                    <span>100 x 100</span>
                </div>
                <div class="stat-row">
                    <span>Cell Size:</span>
                    <span>16px</span>
                </div>
                <div class="stat-row">
                    <span>Tick:</span>
                    <span id="tick">0</span>
                </div>
                <div class="stat-row">
                    <span>NPCs:</span>
                    <span id="npcCount">0</span>
                </div>
                <div class="stat-row">
                    <span>Resources:</span>
                    <span id="resourceCount">0</span>
                </div>
                <div class="stat-row">
                    <span>Buildings:</span>
                    <span id="buildingCount">0</span>
                </div>
            </div>

            <div class="info-panel">
                <div class="info-title">Legend</div>
                <div class="legend">
                    <div class="legend-icon">üë®‚Äçüåæ</div>
                    <div>NPCs</div>

                    <div class="legend-icon">üå≤</div>
                    <div>Trees</div>

                    <div class="legend-icon">ü™®</div>
                    <div>Rocks/Ore</div>

                    <div class="legend-icon">üåæ</div>
                    <div>Berries/Food</div>

                    <div class="legend-icon">üèõÔ∏è</div>
                    <div>Buildings</div>

                    <div class="legend-icon">ü™µ</div>
                    <div>Resources</div>
                </div>
            </div>

            <!-- Pinned Cards in Sidebar -->
            <div id="pinnedCardsContainer" class="pinned-cards-container"></div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('worldCanvas');
        const ctx = canvas.getContext('2d');
        const hoverCard = document.getElementById('hoverCard');
        const CELL_SIZE = 16;
        const GRID_SIZE = 100;

        let worldState = null;
        let hoveredEntity = null;

        // Color mapping for entities
        const colors = {
            npc: '#4CAF50',
            tree: '#8B4513',
            rock: '#808080',
            ore: '#808080',
            berry: '#FF6B6B',
            mushroom: '#D946D9',
            building: '#964B00',
            tavern: '#FFA500',
            water: '#4169E1',
            default: '#FFD700'
        };

        // Icon mapping matching entityUtils.ts
        const ENTITY_ICONS = {
            NPC: 'üë®‚Äçüåæ',
            BUILDING: 'üèõÔ∏è',
            RESOURCE: 'ü™µ',
            UNKNOWN: '‚ùì',
            TREE: 'üå≤',
            ROCK: 'ü™®',
            FOOD: 'üåæ',
        };

        function getEntitySymbol(entity) {
            if (entity.entityType === 'npc' || entity.type === 'npc') return ENTITY_ICONS.NPC;
            if (entity.entityType === 'building' || entity.type === 'building') return ENTITY_ICONS.BUILDING;
            if (entity.entityType === 'resource' || entity.type === 'resource') {
                const type = (entity.resourceType || '').toLowerCase();
                if (type.includes('tree') || type.includes('wood')) return ENTITY_ICONS.TREE;
                if (type.includes('rock') || type.includes('stone') || type.includes('ore')) return ENTITY_ICONS.ROCK;
                if (type.includes('food') || type.includes('berry') || type.includes('wheat')) return ENTITY_ICONS.FOOD;
                return ENTITY_ICONS.RESOURCE;
            }
            return ENTITY_ICONS.UNKNOWN;
        }

        function getEntityColor(entity) {
            if (entity.type === 'npc') return colors.npc;
            if (entity.type === 'building') {
                return entity.buildingType === 'tavern' ? colors.tavern : colors.building;
            }
            if (entity.type === 'resource') {
                const type = entity.resourceType;
                if (type.includes('tree')) return colors.tree;
                if (type.includes('rock') || type.includes('ore')) return colors.ore;
                if (type.includes('berry') || type.includes('food')) return colors.berry;
                if (type.includes('mushroom')) return colors.mushroom;
                if (type.includes('water')) return colors.water;
            }
            return colors.default;
        }

        function getEntitiesAtPosition(gridX, gridY) {
            if (!worldState) return [];

            const entities = [];

            // Check NPCs
            for (const npc of Object.values(worldState.npcs)) {
                const npcX = Math.floor(npc.position.x);
                const npcY = Math.floor(npc.position.y);
                if (npcX === gridX && npcY === gridY) {
                    entities.push({ ...npc, entityType: 'npc' });
                }
            }

            // Check Buildings
            for (const building of Object.values(worldState.buildings)) {
                const buildingX = Math.floor(building.position.x);
                const buildingY = Math.floor(building.position.y);
                if (buildingX === gridX && buildingY === gridY) {
                    entities.push({ ...building, entityType: 'building' });
                }
            }

            // Check Resources
            for (const resource of Object.values(worldState.resources)) {
                const resX = Math.floor(resource.position.x);
                const resY = Math.floor(resource.position.y);
                if (resX === gridX && resY === gridY) {
                    entities.push({ ...resource, entityType: 'resource' });
                }
            }

            return entities;
        }

        function createNPCCard(npc) {
            const hunger = (1 - npc.needs.hunger) * 100;
            const energy = npc.needs.energy * 100;
            const health = npc.stats.health;

            return `
                <div class="hover-card-title">${getEntitySymbol(npc)} ${npc.name}</div>
                <div class="hover-card-section">
                    <div class="hover-card-label">Current Action:</div>
                    <div class="hover-card-value">${npc.currentAction || 'idle'}</div>
                </div>
                <div class="hover-card-section">
                    <div class="hover-card-label">üçñ Hunger: ${hunger.toFixed(0)}%</div>
                    <div class="hover-stat-bar">
                        <div class="hover-stat-fill hunger" style="width: ${hunger}%">${hunger.toFixed(0)}%</div>
                    </div>
                    <div class="hover-card-label">‚ö° Energy: ${energy.toFixed(0)}%</div>
                    <div class="hover-stat-bar">
                        <div class="hover-stat-fill energy" style="width: ${energy}%">${energy.toFixed(0)}%</div>
                    </div>
                    <div class="hover-card-label">‚ù§Ô∏è Health: ${health}%</div>
                    <div class="hover-stat-bar">
                        <div class="hover-stat-fill health" style="width: ${health}%">${health.toFixed(0)}%</div>
                    </div>
                </div>
                <div class="hover-card-section">
                    <div class="hover-card-label">üí∞ Money:</div>
                    <div class="hover-card-value">${npc.stats.money} gold</div>
                </div>
                <div class="hover-card-section">
                    <div class="hover-card-label">üìç Position:</div>
                    <div class="hover-card-value">(${npc.position.x.toFixed(1)}, ${npc.position.y.toFixed(1)})</div>
                </div>
                <div class="hover-card-section">
                    <div class="hover-card-label">‚õèÔ∏è Skills:</div>
                    <div class="hover-card-value">Gathering: ${npc.skills.gathering} | Crafting: ${npc.skills.crafting} | Trading: ${npc.skills.trading}</div>
                </div>
                <div class="hover-card-section">
                    <div class="hover-card-label">üéí Inventory (${npc.inventory.length} items):</div>
                    <div class="hover-inventory-items">
                        ${npc.inventory.map(item => `<div class="hover-inventory-item">${item.type} x${item.quantity}</div>`).join('') || '<div class="hover-inventory-item">Empty</div>'}
                    </div>
                </div>
            `;
        }

        function createResourceCard(resource) {
            return `
                <div class="hover-card-title">${getEntitySymbol(resource)} ${resource.resourceType}</div>
                <div class="hover-card-section">
                    <div class="hover-card-label">Amount:</div>
                    <div class="hover-card-value">${resource.amount}</div>
                </div>
                <div class="hover-card-section">
                    <div class="hover-card-label">üìç Position:</div>
                    <div class="hover-card-value">(${resource.position.x.toFixed(1)}, ${resource.position.y.toFixed(1)})</div>
                </div>
                <div class="hover-card-section">
                    <div class="hover-card-label">Value:</div>
                    <div class="hover-card-value">${resource.properties.value} gold</div>
                </div>
                ${resource.properties.edible ? '<div class="hover-card-section"><div class="hover-card-value">üçñ Edible</div></div>' : ''}
                ${resource.properties.craftingMaterial ? '<div class="hover-card-section"><div class="hover-card-value">üî® Crafting Material</div></div>' : ''}
            `;
        }

        function createBuildingCard(building) {
            return `
                <div class="hover-card-title">${getEntitySymbol(building)} ${building.buildingType}</div>
                <div class="hover-card-section">
                    <div class="hover-card-label">üìç Position:</div>
                    <div class="hover-card-value">(${building.position.x.toFixed(1)}, ${building.position.y.toFixed(1)})</div>
                </div>
                <div class="hover-card-section">
                    <div class="hover-card-label">üí∞ Gold:</div>
                    <div class="hover-card-value">${building.gold || 0}</div>
                </div>
                <div class="hover-card-section">
                    <div class="hover-card-label">üì¶ Inventory:</div>
                    <div class="hover-inventory-items">
                        ${building.inventory.map(item => `<div class="hover-inventory-item">${item.type} x${item.quantity}</div>`).join('') || '<div class="hover-inventory-item">Empty</div>'}
                    </div>
                </div>
            `;
        }

        function updateHoverCardContent() {
            if (!hoveredEntitiesList || hoveredEntitiesList.length === 0) return;
            
            const entity = hoveredEntitiesList[currentHoverIndex];
            let content = '';

            // Add navigation if multiple entities
            if (hoveredEntitiesList.length > 1) {
                content += `
                    <div class="hover-card-nav">
                        <button class="hover-nav-btn" onclick="cycleHoverCard(-1)">‚óÄ</button>
                        <span class="hover-nav-info">${currentHoverIndex + 1} / ${hoveredEntitiesList.length}</span>
                        <button class="hover-nav-btn" onclick="cycleHoverCard(1)">‚ñ∂</button>
                    </div>
                `;
            }

            if (entity.entityType === 'npc') {
                content += createNPCCard(entity);
            } else if (entity.entityType === 'resource') {
                content += createResourceCard(entity);
            } else if (entity.entityType === 'building') {
                content += createBuildingCard(entity);
            }

            hoverCard.innerHTML = content;
        }

        // Global function for button clicks
        window.cycleHoverCard = function(direction) {
            if (hoveredEntitiesList.length > 1) {
                currentHoverIndex = (currentHoverIndex + direction + hoveredEntitiesList.length) % hoveredEntitiesList.length;
                updateHoverCardContent();
            }
        };

        function showHoverCard(entities, mouseX, mouseY, updatePositionOnly = false) {
            if (!entities || entities.length === 0) {
                hoverCard.style.display = 'none';
                return;
            }

            if (!updatePositionOnly) {
                updateHoverCardContent();
            }
            
            hoverCard.style.display = 'block';

            // Position the card near the mouse, but keep it on screen
            const cardRect = hoverCard.getBoundingClientRect();
            const containerRect = canvas.parentElement.getBoundingClientRect();

            let left = mouseX + 15;
            let top = mouseY + 15;

            // Adjust if card would go off-screen
            if (left + cardRect.width > containerRect.right) {
                left = mouseX - cardRect.width - 15;
            }
            if (top + cardRect.height > containerRect.bottom) {
                top = mouseY - cardRect.height - 15;
            }

            hoverCard.style.left = left + 'px';
            hoverCard.style.top = top + 'px';
        }

        function drawGrid() {
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 0.5;

            // Draw vertical lines
            for (let x = 0; x <= GRID_SIZE; x++) {
                ctx.beginPath();
                ctx.moveTo(x * CELL_SIZE, 0);
                ctx.lineTo(x * CELL_SIZE, GRID_SIZE * CELL_SIZE);
                ctx.stroke();
            }

            // Draw horizontal lines
            for (let y = 0; y <= GRID_SIZE; y++) {
                ctx.beginPath();
                ctx.moveTo(0, y * CELL_SIZE);
                ctx.lineTo(GRID_SIZE * CELL_SIZE, y * CELL_SIZE);
                ctx.stroke();
            }
        }

        function drawEntities() {
            if (!worldState) return;

            // Draw resources
            Object.values(worldState.resources).forEach(resource => {
                const x = Math.floor(resource.position.x) * CELL_SIZE;
                const y = Math.floor(resource.position.y) * CELL_SIZE;

                // Draw background circle
                ctx.fillStyle = getEntityColor(resource);
                ctx.beginPath();
                ctx.arc(x + CELL_SIZE / 2, y + CELL_SIZE / 2, CELL_SIZE / 3, 0, Math.PI * 2);
                ctx.fill();

                // Draw icon
                ctx.fillStyle = '#000';
                ctx.font = '10px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(getEntitySymbol({...resource, entityType: 'resource'}), x + CELL_SIZE / 2, y + CELL_SIZE / 2);

                // Amount indicator
                if (resource.amount > 1) {
                    ctx.fillStyle = '#ffffff';
                    ctx.font = '8px Arial';
                    ctx.fillText(resource.amount, x + 4, y + 12);
                }
            });

            // Draw buildings
            Object.values(worldState.buildings).forEach(building => {
                const x = Math.floor(building.position.x) * CELL_SIZE;
                const y = Math.floor(building.position.y) * CELL_SIZE;

                ctx.fillStyle = getEntityColor(building);
                ctx.fillRect(x, y, CELL_SIZE, CELL_SIZE);

                // Draw icon
                ctx.fillStyle = '#000';
                ctx.font = '10px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(getEntitySymbol({...building, entityType: 'building'}), x + CELL_SIZE / 2, y + CELL_SIZE / 2);
            });

            // Draw NPCs (on top)
            Object.values(worldState.npcs).forEach(npc => {
                const x = Math.floor(npc.position.x) * CELL_SIZE;
                const y = Math.floor(npc.position.y) * CELL_SIZE;

                ctx.fillStyle = colors.npc;
                ctx.beginPath();
                ctx.arc(x + CELL_SIZE / 2, y + CELL_SIZE / 2, CELL_SIZE / 3, 0, Math.PI * 2);
                ctx.fill();

                // Draw icon
                ctx.fillStyle = '#000';
                ctx.font = '10px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(getEntitySymbol({...npc, entityType: 'npc'}), x + CELL_SIZE / 2, y + CELL_SIZE / 2);
            });
        }

        function render() {
            // Clear canvas
            ctx.fillStyle = '#0f0f1e';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw grid
            drawGrid();

            // Draw entities
            drawEntities();
        }

        async function fetchState() {
            try {
                const response = await fetch('/state');
                worldState = await response.json();
                
                document.getElementById('tick').textContent = worldState.tick;
                
                render();
            } catch (error) {
                console.error('Failed to fetch state:', error);
            }
        }

        let hoveredEntitiesList = [];
        let currentHoverIndex = 0;

        // Mouse move handler for hover
        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            const gridX = Math.floor((e.clientX - rect.left) / CELL_SIZE);
            const gridY = Math.floor((e.clientY - rect.top) / CELL_SIZE);

            const entities = getEntitiesAtPosition(gridX, gridY);
            
            // Only update if the list of entities has changed significantly (different IDs)
            // or if we moved to a new cell with different entities
            const newIds = entities.map(e => e.id).sort().join(',');
            const oldIds = hoveredEntitiesList.map(e => e.id).sort().join(',');
            
            if (newIds !== oldIds) {
                hoveredEntitiesList = entities;
                currentHoverIndex = 0;
                showHoverCard(hoveredEntitiesList, e.clientX, e.clientY);
            } else if (entities.length > 0) {
                // Just update position if same entities
                showHoverCard(hoveredEntitiesList, e.clientX, e.clientY, true);
            } else {
                hoveredEntitiesList = [];
                hoverCard.style.display = 'none';
            }
        });

        // Hide card when mouse leaves canvas
        canvas.addEventListener('mouseleave', () => {
            hoverCard.style.display = 'none';
            hoveredEntitiesList = [];
        });

        // Handle scroll on hover card to cycle entities
        // We attach this to window or canvas, but check if we are hovering an entity
        window.addEventListener('wheel', (e) => {
            if (hoveredEntitiesList.length > 1) {
                if (e.deltaY > 0) {
                    currentHoverIndex = (currentHoverIndex + 1) % hoveredEntitiesList.length;
                } else {
                    currentHoverIndex = (currentHoverIndex - 1 + hoveredEntitiesList.length) % hoveredEntitiesList.length;
                }
                // Re-render card at current mouse position (we might need to track last mouse pos)
                // For now, just re-render with existing position logic inside showHoverCard if we can
                // But showHoverCard needs x,y. 
                // Let's just update the content if the card is visible.
                if (hoverCard.style.display !== 'none') {
                    updateHoverCardContent();
                }
            }
        });

        // Auto-refresh every second
        setInterval(fetchState, 1000);

        // Initial fetch
        fetchState();

        // Pinned cards management
        const pinnedCardsContainer = document.getElementById('pinnedCardsContainer');
        const pinnedEntities = new Map(); // entityId => entity data

        function pinEntity(entity) {
            if (!entity || pinnedEntities.has(entity.id)) return;

            pinnedEntities.set(entity.id, entity);
            updatePinnedCards();
        }

        function unpinEntity(entityId) {
            pinnedEntities.delete(entityId);
            updatePinnedCards();
        }

        function togglePinnedCard(entityId) {
            const card = document.querySelector(`[data-entity-id="${entityId}"]`);
            if (card) {
                card.classList.toggle('collapsed');
            }
        }

        function updatePinnedCards() {
            pinnedCardsContainer.innerHTML = '';

            pinnedEntities.forEach((entity, entityId) => {
                // Refresh entity data from current world state
                let currentEntity = entity;
                if (worldState) {
                    if (entity.entityType === 'npc' && worldState.npcs[entityId]) {
                        currentEntity = { ...worldState.npcs[entityId], entityType: 'npc' };
                        pinnedEntities.set(entityId, currentEntity);
                    } else if (entity.entityType === 'building' && worldState.buildings[entityId]) {
                        currentEntity = { ...worldState.buildings[entityId], entityType: 'building' };
                        pinnedEntities.set(entityId, currentEntity);
                    } else if (entity.entityType === 'resource' && worldState.resources[entityId]) {
                        currentEntity = { ...worldState.resources[entityId], entityType: 'resource' };
                        pinnedEntities.set(entityId, currentEntity);
                    }
                }

                const card = document.createElement('div');
                card.className = 'pinned-card';
                card.setAttribute('data-entity-id', entityId);

                // Create card header
                const header = document.createElement('div');
                header.className = 'pinned-card-header';
                header.onclick = () => togglePinnedCard(entityId);

                const headerLeft = document.createElement('div');
                headerLeft.className = 'pinned-card-header-left';

                const toggle = document.createElement('span');
                toggle.className = 'pinned-card-toggle';
                toggle.textContent = '‚ñº';

                const title = document.createElement('span');
                title.className = 'pinned-card-title-text';
                
                if (currentEntity.entityType === 'npc') {
                    title.textContent = `${getEntitySymbol(currentEntity)} ${currentEntity.name}`;
                } else if (currentEntity.entityType === 'building') {
                    title.textContent = `${getEntitySymbol(currentEntity)} ${currentEntity.buildingType}`;
                } else if (currentEntity.entityType === 'resource') {
                    title.textContent = `${getEntitySymbol(currentEntity)} ${currentEntity.resourceType}`;
                }

                headerLeft.appendChild(toggle);
                headerLeft.appendChild(title);

                const closeBtn = document.createElement('button');
                closeBtn.className = 'pinned-card-close';
                closeBtn.textContent = '√ó';
                closeBtn.onclick = (e) => {
                    e.stopPropagation();
                    unpinEntity(entityId);
                };

                header.appendChild(headerLeft);
                header.appendChild(closeBtn);

                // Create card content
                const content = document.createElement('div');
                content.className = 'pinned-card-content';

                if (currentEntity.entityType === 'npc') {
                    content.innerHTML = createNPCCard(currentEntity);
                } else if (currentEntity.entityType === 'resource') {
                    content.innerHTML = createResourceCard(currentEntity);
                } else if (currentEntity.entityType === 'building') {
                    content.innerHTML = createBuildingCard(currentEntity);
                }

                card.appendChild(header);
                card.appendChild(content);
                pinnedCardsContainer.appendChild(card);
            });
        }

        // Make unpinEntity global
        window.unpinEntity = unpinEntity;

        // Handle canvas clicks to pin entities
        canvas.addEventListener('click', (e) => {
            if (hoveredEntitiesList.length > 0) {
                const entity = hoveredEntitiesList[currentHoverIndex];
                if (entity) {
                    pinEntity(entity);
                }
            }
        });

        // Simulation control
        const playBtn = document.getElementById('playBtn');
        const pauseBtn = document.getElementById('pauseBtn');
        const speedBtns = document.querySelectorAll('.speed-btn');

        let currentSpeed = 1;
        let isPaused = false;

        async function updateSimulationStatus() {
            try {
                const response = await fetch('/simulation/status');
                const status = await response.json();
                isPaused = status.paused;
                currentSpeed = status.speed;

                // Update UI
                playBtn.classList.toggle('active', !isPaused);
                pauseBtn.classList.toggle('active', isPaused);

                speedBtns.forEach(btn => {
                    const speed = parseInt(btn.dataset.speed);
                    btn.classList.toggle('active', speed === currentSpeed);
                });
            } catch (error) {
                console.error('Failed to fetch simulation status:', error);
            }
        }

        playBtn.addEventListener('click', async () => {
            try {
                await fetch('/simulation/play', { method: 'POST' });
                await updateSimulationStatus();
            } catch (error) {
                console.error('Failed to play simulation:', error);
            }
        });

        pauseBtn.addEventListener('click', async () => {
            try {
                await fetch('/simulation/pause', { method: 'POST' });
                await updateSimulationStatus();
            } catch (error) {
                console.error('Failed to pause simulation:', error);
            }
        });

        speedBtns.forEach(btn => {
            btn.addEventListener('click', async () => {
                const speed = parseInt(btn.dataset.speed);
                try {
                    await fetch('/simulation/speed', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ speed })
                    });
                    await updateSimulationStatus();
                } catch (error) {
                    console.error('Failed to set speed:', error);
                }
            });
        });

        // Initial status update
        updateSimulationStatus();
        setInterval(updateSimulationStatus, 2000); // Update status every 2 seconds
    </script>
</body>
</html>
